-- Mock helpers for testing aicommits.nvim
-- Provides utilities for mocking vim.fn.system calls and other external dependencies

local M = {}

-- Store original functions
M.originals = {}

--- Mock vim.fn.system to return specific output
--- @param responses table Map of command patterns to responses
--- @return function cleanup function to restore original
function M.mock_system(responses)
  M.originals.system = vim.fn.system

  vim.fn.system = function(cmd)
    local cmd_str = type(cmd) == "table" and table.concat(cmd, " ") or cmd

    -- Check each response pattern
    for pattern, response in pairs(responses) do
      if cmd_str:match(pattern) then
        if type(response) == "table" then
          -- Note: We cannot mock vim.v.shell_error as it's read-only
          -- Tests should check the actual output/behavior instead
          return response.output or ""
        else
          return response
        end
      end
    end

    -- Default: call original
    return M.originals.system(cmd)
  end

  -- Return cleanup function
  return function()
    vim.fn.system = M.originals.system
  end
end

--- Mock vim.fn.executable to control which commands are available
--- @param executables table Map of command names to availability (1 or 0)
--- @return function cleanup function to restore original
function M.mock_executable(executables)
  M.originals.executable = vim.fn.executable

  vim.fn.executable = function(name)
    if executables[name] ~= nil then
      return executables[name]
    end
    return M.originals.executable(name)
  end

  return function()
    vim.fn.executable = M.originals.executable
  end
end

--- Mock environment variables
--- @param env_vars table Map of variable names to values
--- @return function cleanup function to restore originals
function M.mock_env(env_vars)
  M.originals.env = {}

  for key, value in pairs(env_vars) do
    M.originals.env[key] = vim.fn.getenv(key)
    vim.fn.setenv(key, value)
  end

  return function()
    for key, original_value in pairs(M.originals.env) do
      vim.fn.setenv(key, original_value)
    end
  end
end

--- Create a mock response for aicommits CLI
--- @param opts table Options for the mock response
--- @return table Response object
function M.aicommits_response(opts)
  opts = opts or {}
  local success = opts.success ~= false
  local message = opts.message or "feat: add new feature\n\nThis is a commit message generated by AI"

  return {
    output = message,
    exit_code = success and 0 or 1,
  }
end

--- Create a mock git repository state
--- @param opts table Options for git state
--- @return table Cleanup functions
function M.mock_git_repo(opts)
  opts = opts or {}
  local has_staged = opts.has_staged ~= false
  local is_repo = opts.is_repo ~= false
  local has_remote = opts.has_remote ~= false

  local cleanup = M.mock_system({
    ["git rev%-parse %-%-is%-inside%-work%-tree"] = {
      output = is_repo and "true" or "",
      exit_code = is_repo and 0 or 128,
    },
    ["git diff %-%-cached %-%-quiet"] = {
      output = "",
      exit_code = has_staged and 1 or 0, -- non-zero = changes exist
    },
    ["git diff %-%-cached %-%-name%-only"] = {
      output = has_staged and "file1.lua\nfile2.lua" or "",
      exit_code = 0,
    },
    ["git remote %-v"] = {
      output = has_remote and "origin\thttps://github.com/user/repo.git (fetch)" or "",
      exit_code = has_remote and 0 or 1,
    },
  })

  return cleanup
end

return M
